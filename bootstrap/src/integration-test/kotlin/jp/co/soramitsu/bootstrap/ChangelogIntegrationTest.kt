package jp.co.soramitsu.bootstrap

import com.d3.commons.util.getRandomString
import com.d3.commons.util.toHexString
import com.google.gson.Gson
import jp.co.soramitsu.bootstrap.changelog.ChangelogInterface
import jp.co.soramitsu.bootstrap.dto.*
import jp.co.soramitsu.crypto.ed25519.Ed25519Sha3
import jp.co.soramitsu.iroha.java.IrohaAPI
import jp.co.soramitsu.iroha.java.QueryAPI
import jp.co.soramitsu.iroha.java.Utils
import org.junit.AfterClass
import org.junit.Assert.assertEquals
import org.junit.Test
import org.junit.runner.RunWith
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.http.MediaType
import org.springframework.test.context.junit4.SpringRunner
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders
import org.springframework.test.web.servlet.result.MockMvcResultMatchers
import java.io.File

//Here lies the sample changelog script
private const val SAMPLE_CHANGELOG_PATH = "deploy/bootstrap/changelogs/sample_changelog.groovy"
//Script file generated by the test
private const val TEST_CHANGELOG_PATH = "deploy/bootstrap/changelogs/test_changelog.groovy"

//Iroha configs
private const val IROHA_HOST = "d3-iroha"
private const val IROHA_PORT = 50051

@RunWith(SpringRunner::class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class ChangelogIntegrationTest {

    private companion object {

        /*
        We need this thing because Spring tests are run using old junit.
        @AfterAll is not going to work here. The only way to close resources is using @AfterClass annotation.
        But methods annotated with @AfterClass MUST be static.
        */
        private val irohaAPI = IrohaAPI(IROHA_HOST, IROHA_PORT)

        @AfterClass
        @JvmStatic
        fun tearDown() {
            irohaAPI.close()
        }
    }

    private val superuserKeyPair = Utils.parseHexKeypair(
        File("deploy/iroha/keys/superuser@bootstrap.pub").readText(),
        File("deploy/iroha/keys/superuser@bootstrap.priv").readText()
    )
    private val gson = Gson()

    @Autowired
    private lateinit var mvc: MockMvc

    /**
     * @given script file with Iroha account creation logic
     * @when script file is passed to changelog service
     * @then account is created
     */
    @Test
    fun testExecuteFile() {
        //Create file that creates randomly named account
        val randomAccountName = String.getRandomString(9)
        createAccountScriptFile(randomAccountName)
        mvc.perform(
            MockMvcRequestBuilders
                .post("/changelog/execute/changelogFile")
                .contentType(MediaType.APPLICATION_JSON).content(
                    gson.toJson(
                        createChangelogFileRequest(
                            randomAccountName
                        )
                    )
                )
        ).andExpect(MockMvcResultMatchers.status().isOk).andReturn()

        val queryAPI = QueryAPI(irohaAPI, ChangelogInterface.superuserAccountId, superuserKeyPair)
        val account =
            queryAPI.getAccount(
                "$randomAccountName@d3"
            ).account
        assertEquals("{\"superuser@bootstrap\": {\"test_key\": \"test_value\"}}", account.jsonData)
    }

    /**
     * @given script with Iroha account creation logic
     * @when script is passed to changelog service
     * @then account is created
     */
    @Test
    fun testExecuteScript() {
        //Create file that creates randomly named account
        val randomAccountName = String.getRandomString(9)
        mvc.perform(
            MockMvcRequestBuilders
                .post("/changelog/execute/changelogScript")
                .contentType(MediaType.APPLICATION_JSON).content(
                    gson.toJson(
                        createChangelogScriptRequest(
                            randomAccountName
                        )
                    )
                )
        ).andExpect(MockMvcResultMatchers.status().isOk).andReturn()

        val queryAPI = QueryAPI(irohaAPI, ChangelogInterface.superuserAccountId, superuserKeyPair)
        val account =
            queryAPI.getAccount(
                "$randomAccountName@d3"
            ).account
        assertEquals("{\"superuser@bootstrap\": {\"test_key\": \"test_value\"}}", account.jsonData)
    }

    /**
     * Creates test file based changelog request
     */
    private fun createChangelogFileRequest(accountName: String): ChangelogFileRequest {
        return ChangelogFileRequest(
            changelogFile = TEST_CHANGELOG_PATH,
            details = ChangelogRequestDetails(
                accounts = listOf(
                    AccountPublicInfo(
                        accountName = accountName,
                        domainId = "d3",
                        pubKeys = listOf(Ed25519Sha3().generateKeypair().public.toHexString())
                    )
                ),
                irohaConfig = IrohaConfig(IROHA_HOST, IROHA_PORT),
                superuserKeys = listOf(
                    ClientKeyPair(
                        Utils.toHex(superuserKeyPair.public.encoded),
                        Utils.toHex(superuserKeyPair.private.encoded)
                    )
                )
            )
        )
    }

    /**
     * Creates test script based changelog request
     */
    private fun createChangelogScriptRequest(accountName: String): ChangelogScriptRequest {
        return ChangelogScriptRequest(
            script = createAccountScript(accountName),
            details = ChangelogRequestDetails(
                accounts = listOf(
                    AccountPublicInfo(
                        accountName = accountName,
                        domainId = "d3",
                        pubKeys = listOf(Ed25519Sha3().generateKeypair().public.toHexString())
                    )
                ),
                irohaConfig = IrohaConfig(IROHA_HOST, IROHA_PORT),
                superuserKeys = listOf(
                    ClientKeyPair(
                        Utils.toHex(superuserKeyPair.public.encoded),
                        Utils.toHex(superuserKeyPair.private.encoded)
                    )
                )
            )
        )
    }

    /**
     * Returns script that creates account in Iroha
     * @param accountName - name of account to create in script
     * @return script
     */
    private fun createAccountScript(accountName: String): String {
        val script = File(SAMPLE_CHANGELOG_PATH).readText()
        return script.replace("script_test", accountName)
    }

    /**
     * Creates script file that creates account in Iroha
     * @param accountName - name of account to create in script file
     */
    private fun createAccountScriptFile(accountName: String) {
        File(TEST_CHANGELOG_PATH).writeText(createAccountScript(accountName))
    }
}
